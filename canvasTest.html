<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" href="http://blueimp.github.com/cdn/css/bootstrap.min.css" />
<style>
.btn-toggle input {
	display: none;
}
</style>
</head>
<body>
<div class="container">
	<canvas width="1000" height="600"></canvas><br>
	<div class="form-inline">
		<button class="btn">Fullscreen</button>
		<button class="btn">Add Sun</button>
		<button class="btn">Add 10 Balls</button>
		<button class="btn">Enable Debug Lines</button>
		<div class="btn-group">
			<button class="btn">Refresh Tree</button>
			<label class="btn btn-toggle" for="continuous-refresh-chk">
				<input type="checkbox" id="continuous-refresh-chk" />
				<i class="icon-refresh"></i>
			</label>
		</div><br>
		<div class="input-prepend">
			<label for="left-click-slt" class="add-on">Left Click</label>
			<select id="left-click-slt">
				<option value="set-point-mass">Set Point Mass</option>
				<option value="add-point-mass">Add Point Mass</option>
				<option value="add-sun">Add Sun</option>
				<option value="add-ball">Add Red Ball</option>
				<option value="add-background">Extend Background</option>
			</select>
		</div>
		<div class="input-prepend">
			<label for="right-click-slt" class="add-on">Right Click</label>
			<select id="right-click-slt">
				<option value="remove-point-mass">Remove Point Mass</option>
				<option value="remove-sun">Remove Sun</option>
				<option value="remove-ball">Remove Red Ball</option>
				<option value="remove-background">Remove Background Point</option>
			</select>
		</div>
	</div>
	<div id="game-tree"></div>
</div>
<script src="http://code.jquery.com/jquery-latest.js"></script>
<script src="http://blueimp.github.com/cdn/js/bootstrap.js"></script>
<script>
(function(){
	Array.prototype.remove = function(from, to) {
		var rest = this.slice((to || from) + 1 || this.length);
		this.length = from < 0 ? this.length + from : from;
		return this.push.apply(this, rest);
	};
	function drawCircle(ctx, x, y, r){
		ctx.beginPath();
		ctx.arc(x, y, r, 0, Math.PI * 2);
	};
	function drawEllipse(ctx, x, y, xr, yr){
	  var kappa = .5522848;
		  ox = xr * kappa, // control point offset horizontal
		  oy = yr * kappa, // control point offset vertical
		  xe = x + xr;       // x-end
		  ye = y + yr,       // y-end
		  xs = x - xr,       // x-start
		  ys = y - yr;       // y-start

	  ctx.beginPath();
	  ctx.moveTo(xs, y);
	  ctx.bezierCurveTo(xs, y - oy, x - ox, ys, x, ys);
	  ctx.bezierCurveTo(x + ox, ys, xe, y - oy, xe, y);
	  ctx.bezierCurveTo(xe, y + oy, x + ox, ye, x, ye);
	  ctx.bezierCurveTo(x - ox, ye, xs, y + oy, xs, y);
	  ctx.closePath();
	};
	CanvasRenderingContext2D.prototype.strokeCircle = function(x, y, radius){
		drawCircle(this, x, y, radius);
		this.stroke();
	};
	CanvasRenderingContext2D.prototype.fillCircle = function(x, y, radius){
		drawCircle(this, x, y, radius);
		this.fill();
	};
	CanvasRenderingContext2D.prototype.strokeEllipse = function(x, y, xr, yr) {
		drawEllipse(this, x, y, xr, yr);
		this.stroke();
	};
	CanvasRenderingContext2D.prototype.fillEllipse = function(x, y, xr, yr) {
		drawEllipse(this, x, y, xr, yr);
		this.fill();
	};
	Function.prototype.extend = function(name) {
		function Class() {
			if (!(this instanceof Class))
				throw('Constructor called without "new"');
			if ('_init' in this)
				this._init.apply(this, arguments);
			this.name = name;
		}
		Function.prototype.extend.nonconstructor.prototype = this.prototype;
		Class.prototype = new Function.prototype.extend.nonconstructor();
		return Class;
	};
	Function.prototype.extend.nonconstructor= function() {};
})();
window.onload = function(){
	// -----------------
	// Define Components
	// -----------------
	var GameObject = Object.extend("GameObject");
	GameObject.prototype._init = function(x, y){
		this.components = [];
		this.x = x;
		this.y = y;
		this.vx = 0;
		this.vy = 0;
	};
	GameObject.prototype.addComponent = function(component){
		if(component instanceof GameComponent)
			this.components.push(component);
	};
	GameObject.prototype.update = function(delta){
		var i = 0,
			l = this.components.length;
		for(;i<l;i++)
			this.components[i].update(this, delta);
	};
	GameObject.prototype.toHTML = function() {
		var html = this.name;
		if(typeof this.x == "number")
			html += " (" + this.x.toFixed() + "," + this.y.toFixed() + ")";
		if(this.components.length){
			html += "<ul>";
			for(var i=0;i<this.components.length;i++)
				html += "<li>"+this.components[i].toHTML();
			html += "</ul>";
		}
		return html;
	};
	var GameObjectManager = GameObject.extend("GameObjectManager");
	GameObjectManager.prototype._init = function(){
		GameObject.prototype._init.call(this);
		this.objects = [];
		this.toBeRemoved = [];
	};
	GameObjectManager.prototype.addObject = function(object){
		if(object instanceof GameObject)
			this.objects.push(object);
	};
	GameObjectManager.prototype.addObjectAt = function(index, object){
		if(object instanceof GameObject)
			this.objects.splice(index,0,object);
	};
	GameObjectManager.prototype.removeObject = function(object){
		if(!object instanceof GameObject)
			return;
		this.toBeRemoved.push(object);
	};
	GameObjectManager.prototype.update = function(delta){
		var i = 0,
			l = this.objects.length,
			m = this.toBeRemoved.length,
			j = 0;
		for(;i<l;i++)
			this.objects[i].update(delta);

		for(;j<m;j++){
			i = 0;
			for(;i<l;i++){
				if(this.objects[i] == this.toBeRemoved[j]){
					this.objects.remove(i);
					return;
				}
			}
		}
	};
	GameObjectManager.prototype.toHTML = function() {
		var html = this.name;
		if(this.objects.length > 1)
			html += " (" + this.objects.length + " items)";
		if(this.components.length){
			html += "<ul>";
			for(var i=0;i<this.components.length;i++)
				html += "<li>"+this.components[i].toHTML();
			html += "</ul>";
		}
		if(this.objects.length){
			html += "<ul>";
			for(var i=0;i<this.objects.length;i++)
				html += "<li>"+this.objects[i].toHTML();
			html += "</ul>";
		}
		return html;
	};

	var CanvasManager = GameObject.extend("CanvasManager");
	CanvasManager.prototype._init = function(context){
		GameObject.prototype._init.call(this);
		this.context = context;
	};
	CanvasManager.prototype.update = function(delta){
		this.context.fillStyle = "#fff";
		this.context.fillRect(0,0,this.context.canvas.width,this.context.canvas.height);
	}
	var GameComponent = Object.extend("GameComponent");
	GameComponent.prototype.update = function(parent, delta){};
	GameComponent.prototype.toHTML = function() {
		return this.name;
	};
	var MoveComponent = GameComponent.extend("MoveComponent");
	MoveComponent.prototype.update = function(parent, delta) {
		if(parent.vx)
			parent.x += parent.vx * delta;
		if(parent.vy)
			parent.y += parent.vy * delta;
	};
	var DrawComponent = GameComponent.extend("DrawComponent");
	DrawComponent.prototype._init = function(context, size, colour){
		this.context = context;
		this.size = size;
		this.colour = colour;
	};
	DrawComponent.prototype.update = function(parent, delta) {
		this.context.fillStyle = this.colour;
		this.context.fillCircle(parent.x,parent.y,this.size);
		this.context.fillStyle = "rgba(255,255,255,0.7)";
		this.context.fillCircle(parent.x+this.size*0.33,parent.y-this.size*0.33,this.size*0.45);
	};
	var DebugDrawPathComponent = GameComponent.extend("DebugDrawPathComponent");
	DebugDrawPathComponent.prototype._init = function(context){
		this.context = context;
		this.path = [];
		this.pathSize = 1000;
		this.pathIndex = 0;
		this.lastVx = 0;
		this.lastVy = 0;
	};
	DebugDrawPathComponent.prototype.update = function(parent, delta) {
		if(debugLines){
			var skip = this.pathIndex % this.pathSize;
			this.context.strokeStyle = "#CCC";
			this.context.beginPath();
			this.context.moveTo(parent.x, parent.y);
			if(this.pathIndex > this.pathSize){
				for(var i = this.pathSize-1;i>=0;i--){
					var index = (i + skip + this.pathSize) % this.pathSize;
					this.context.lineTo(this.path[index][0],this.path[index][1]);
				}
			}else{
				for(var i = this.pathIndex-1;i>=0;i--){
					this.context.lineTo(this.path[i][0],this.path[i][1]);
				}
			}
			this.context.stroke();
			this.pathIndex++;
			this.path[skip] = [parent.x,parent.y];
			this.context.strokeStyle = "rgba(0,128,255,0.7)";
			this.context.beginPath();
			this.context.moveTo(parent.x, parent.y);
			this.context.lineTo(parent.x+parent.vx*100, parent.y+parent.vy*100);
			this.context.stroke();
			var ax = (parent.vx - this.lastVx)/delta,
				ay = (parent.vy - this.lastVy)/delta;
			this.lastVx = parent.vx;
			this.lastVy = parent.vy;
			this.context.strokeStyle = "rgba(0,255,0,0.7)";
			this.context.beginPath();
			this.context.moveTo(parent.x, parent.y);
			this.context.lineTo(parent.x+ax*4e5, parent.y+ay*4e5);
			this.context.stroke();
		}else{
			this.pathIndex = 0;
		}
	};
	var BounceComponent = GameComponent.extend("BounceComponent");
	BounceComponent.prototype._init = function(width, height, roomWidth, roomHeight) {
		this.ax = width / 2;
		this.ay = height / 2;
		this.bx = roomWidth - this.ax;
		this.by = roomHeight - this.ay;
	};
	BounceComponent.prototype.update = function(parent, delta) {
		var coef = 0.9;
		if(parent.x < this.ax){
			parent.x = this.ax;
			parent.vx = -parent.vx*coef;
		}
		if(parent.x > this.bx){
			parent.x = this.bx;
			parent.vx = -parent.vx*coef;
		}
		if(parent.y < this.ay){
			parent.y = this.ay;
			parent.vy = -parent.vy*coef;
		}
		if(parent.y > this.by){
			parent.y = this.by;
			parent.vy = -parent.vy*coef;
		}
	};
	var GravityComponent = GameComponent.extend("GravityComponent");
	GravityComponent.prototype.update = function(parent, delta) {
		if(typeof parent.vy == "undefined")
			parent.vy = 0;
		parent.vy += 0.0001*delta;
	};
	var RandomMoveComponent = GameComponent.extend("RandomMoveComponent");
	RandomMoveComponent.prototype.update = function(parent, delta) {
		if(Math.random()<0.001){
			parent.vx = Math.random()-0.5;
			parent.vy = Math.random()-0.5;
		}
	};
	var PointGravityComponent = GameComponent.extend("PointGravityComponent");
	PointGravityComponent.prototype._init = function(object) {
		this.object = object;
	};
	PointGravityComponent.prototype.update = function(parent, delta) {
		var dx = this.object.x - parent.x,
			dy = this.object.y - parent.y,
			theta = Math.atan2(dx, dy);
		parent.vx += Math.sin(theta)*0.0001*this.object.mass*delta;
		parent.vy += Math.cos(theta)*0.0001*this.object.mass*delta;
	};
	var CollisionComponent = GameComponent.extend("CollisionComponent");
	CollisionComponent.prototype._init = function(width, height) {
		this.halfWidth = width / 2;
		this.halfHeight = height / 2;
	};
	CollisionComponent.prototype.update = function(parent, delta) {
		var bounds = sCollisionSystem.getBounds(),
			i = 0,
			l = bounds.length,
			collision = false;
		for(; i < l; i++){
			collision = (
					parent.x + this.halfWidth > bounds[i][0] &&
					parent.x - this.halfWidth  < bounds[i][2] &&
					parent.y + this.halfHeight > bounds[i][1] &&
					parent.y - this.halfHeight < bounds[i][3]
				) ? bounds[i][4] : false;
			if(collision)
				break;
		}

		if(collision){
			switch(collision.name){
				case "MassiveObject":
					gameRoot.removeObject(parent);
					break;
				case "RedBall":
					if(collision != parent){
						parent.vx = -parent.vx*0.9;
						parent.vy = -parent.vy*0.9;
					}
					break;
			}
		}
	};
	var CollisionSystem = GameObject.extend("CollisionSystem");
	CollisionSystem.prototype._init = function() {
		GameObject.prototype._init.call(this);
		this.bounds = [[],[]];
		this.boundsCount = 2;
		this.readIndex = 1;
		this.writeIndex = 0;
	};
	CollisionSystem.prototype.update = function(delta) {
		GameObject.prototype.update.call(this,delta);
		this.readIndex = (this.readIndex + 1) % this.boundsCount;
		this.writeIndex = (this.writeIndex + 1) % this.boundsCount;
		//this.boundsIndex = (this.boundsIndex + 1) % this.boundsCount;
		this.bounds[this.writeIndex] = [];
	};
	CollisionSystem.prototype.addCollisionBounds = function(x,y,w,h,object){
		this.getNextBounds().push([x-w/2,y-h/2,x+w/2,y+h/2,object]);
	};
	CollisionSystem.prototype.getBounds = function(){
		return this.bounds[this.readIndex];
	}
	CollisionSystem.prototype.getNextBounds = function(){
		return this.bounds[this.writeIndex];
	}
	var SolidComponent = GameComponent.extend("SolidComponent");
	SolidComponent.prototype._init = function(width, height, object) {
		this.width = width;
		this.height = height;
		this.object = object;
	};
	SolidComponent.prototype.update = function(parent, delta) {
		sCollisionSystem.addCollisionBounds(parent.x, parent.y, this.width, this.height, this.object);
	};
	var DebugDrawBoundsComponent = GameComponent.extend("DebugDrawBoundsComponent");
	DebugDrawBoundsComponent.prototype._init = function(context){
		this.context = context;
	}
	DebugDrawBoundsComponent.prototype.update = function(parent, delta) {
		if(debugLines){
			var bounds = sCollisionSystem.getBounds();
			for(var i=0;i<bounds.length;i++){
				var bound = bounds[i];
				this.context.strokeStyle = "#999";
				this.context.strokeRect(bound[0],bound[1],bound[2]-bound[0],bound[3]-bound[1]);
			}
		}
	};
	var InputSystem = GameObject.extend("InputSystem");
	InputSystem.prototype._init = function() {
		GameObject.prototype._init.call(this);
		this.hasInput = false;
		this.lastInput = null;
	};
	InputSystem.prototype.update = function(parent, delta) {
		//this.hasInput = false;
	};
	InputSystem.prototype.click = function(x,y){
		this.hasInput = true;
		this.lastInput = {x: x, y: y};
	}
	var MoveToClickComponent = GameComponent.extend("MoveToClickComponent");
	MoveToClickComponent.prototype.update = function(parent, delta) {
		if(sInputSystem.hasInput){
			parent.x = sInputSystem.lastInput.x;
			parent.y = sInputSystem.lastInput.y;
			sInputSystem.hasInput = false;
		}
	};
	var AirResistanceComponent = GameComponent.extend("AirResistanceComponent");
	AirResistanceComponent.prototype._init = function(csa,rho) {
		this.csa = csa;
		this.rho = typeof rho == "number" ? rho : 0.001;
	};
	AirResistanceComponent.prototype.update = function(parent,delta) {
		var mag2 = parent.vx*parent.vx + parent.vy*parent.vy,
			theta = Math.atan2(parent.vx, parent.vy),
			dv = mag2*this.rho*this.csa*delta,
			dvx = Math.abs(Math.sin(theta)*dv),
			dvy = Math.abs(Math.cos(theta)*dv);
			// Math.abs... Math.min....
		if(dvx > Math.abs(parent.vx))
			parent.vx = 0;
		else
			parent.vx = parent.vx + (parent.vx < 0 ? dvx : -dvx);
		if(dvy > Math.abs(parent.vy))
			parent.vy = 0;
		else
			parent.vy = parent.vy + (parent.vy < 0 ? dvy : -dvy);
	};
	var DebugDrawDataComponentCount = 0,
		DebugDrawDataComponent = GameComponent.extend("DebugDrawDataComponent");
	DebugDrawDataComponent.prototype._init = function(context, desc) {
		this.context = context;
		this.desc = desc;
		this.xOffset = DebugDrawDataComponentCount * 70 + 10;
		DebugDrawDataComponentCount++;
		this.maxX = this.maxY = this.maxVx = this.maxVy = this.maxV = 0;
	};
	DebugDrawDataComponent.prototype.update = function(parent, delta) {
		this.maxX = Math.max(this.maxX, parent.x);
		this.maxY = Math.max(this.maxY, parent.y);
		this.maxVx = Math.max(this.maxVx, parent.vx);
		this.maxVy = Math.max(this.maxVy, parent.vy);
		this.maxV = Math.max(this.maxV,Math.sqrt(parent.vx*parent.vx + parent.vy*parent.vy));
		this.context.fillStyle = "#999";
		var y = 0;
		if(typeof this.desc == "string")
			this.context.fillText(this.desc, this.xOffset, y+=15);
		this.context.fillText("x: " + parent.x.toFixed(), this.xOffset, y+=15);
		this.context.fillText("y: " + parent.y.toFixed(), this.xOffset, y+=15);
		this.context.fillText("vx: " + parent.vx.toFixed(3), this.xOffset, y+=15);
		this.context.fillText("vy: " + parent.vy.toFixed(3), this.xOffset, y+=15);
		this.context.fillText("v: " + Math.sqrt(parent.vx*parent.vx + parent.vy*parent.vy).toFixed(3), this.xOffset, y+=15);
		this.context.fillText("max x: " + this.maxX.toFixed(), this.xOffset, y+=15);
		this.context.fillText("max y: " + this.maxY.toFixed(), this.xOffset, y+=15);
		this.context.fillText("max vx: " + this.maxVx.toFixed(3), this.xOffset, y+=15);
		this.context.fillText("max vy: " + this.maxVy.toFixed(3), this.xOffset, y+=15);
		this.context.fillText("max v: " + this.maxV.toFixed(3), this.xOffset, y+=15);
	};
	var BackgroundSystem = GameObject.extend("BackgroundSystem");
	BackgroundSystem.prototype._init = function(context, coords) {
		this.context = context;
		this.coords = coords;
	};
	BackgroundSystem.prototype.update = function(delta) {
		GameObject.prototype._init.call(this);
		var c = this.coords,
			i = 2,
			l = c.length;
		this.context.strokeStyle = "#000";
		this.context.beginPath();
		this.context.moveTo(c[0],c[1]);
		for(;i<l-1;i+=2)
			this.context.lineTo(c[i],c[i+1]);
		this.context.stroke();

		if(debugLines){
		this.context.strokeStyle = "#08f";
			this.context.beginPath();
			for(i=0;i<l-3;i+=2){
				var x1 = c[i],
					y1 = c[i+1],
					x2 = c[i+2],
					y2 = c[i+3],
					dx = x2 - x1,
					dy = y2 - y1,
					mx = x1 + dx * 0.5,
					my = y1 + dy * 0.5,
					nx = dy / Math.sqrt(dy * dy + dx * dx),
					ny = -dx / Math.sqrt(dy * dy + dx * dx);
				this.context.moveTo(mx,my);
				this.context.lineTo(mx+nx*30,my+ny*30);
			}
			this.context.stroke();
		}
	};
	var BackgroundCollisionComponent = GameComponent.extend("BackgroundCollisionComponent");
	BackgroundCollisionComponent.prototype.update = function(parent, delta)
	{
		var c = sBackgroundSystem.coords,
			i = 0,
			l = c.length,
			px,py,rx,ry,qx,qy,sx,sy,t,u,
			nx,ny,ux,uy,wx,wy,scale,
			f = 0.5,
			r = 0.9;
		if(this.lastX){
			for(;i<l-3;i+=2)
			{
				// http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect
				px = c[i];
				py = c[i+1];
				rx = c[i+2]-px;
				ry = c[i+3]-py;
				qx = this.lastX;
				qy = this.lastY;
				sx = parent.x - qx;
				sy = parent.y - qy;
				t = ((qx - px) * sy - (qy - py) * sx) / (rx * sy - ry * sx);
				u = ((qx - px) * ry - (qy - py) * rx) / (rx * sy - ry * sx);
				if(t >= 0 && t <= 1 && u >= 0 && u <= 1)
				{
					parent.x = this.lastX;
					parent.y = this.lastY;
					// http://stackoverflow.com/questions/573084/how-to-calculate-bounce-angle
					nx = ry / Math.sqrt(ry * ry + rx * rx);
					ny = -rx / Math.sqrt(ry * ry + rx * rx);
					scale = (parent.vx * nx + parent.vy * ny);
					ux = nx * scale;
					uy = ny * scale;
					wx = parent.vx - ux;
					wy = parent.vy - uy;
					parent.vx = wx*f - ux*r;
					parent.vy = wy*f - uy*r;
					break;
				}
			}
		}
		this.lastX = parent.x;
		this.lastY = parent.y;
	}
	var GravitateToClickComponent = GameComponent.extend("GravitateToClickComponent");
	GravitateToClickComponent.prototype.update = function(parent, delta){
		if(sInputSystem.hasInput){
			var dx = sInputSystem.lastInput.x - parent.x,
				dy = sInputSystem.lastInput.y - parent.y,
				theta = Math.atan2(dx, dy);
			parent.vx += Math.sin(theta)*0.001*delta;
			parent.vy += Math.cos(theta)*0.001*delta;
		}
	}


	// -----------------
	// Create Game Graph
	// -----------------
	var ctx = document.getElementsByTagName('canvas')[0].getContext('2d'),
		gameRoot = new GameObjectManager(),
		width = ctx.canvas.width,
		height = ctx.canvas.height,
		ballSize = 4,
	    random = function(sd, mean){
	        var d=10, r=0, i=0;
	        for(;i<d;i++)
	            r += Math.random();
	        r = r / d * 2 - 1;
	        if(typeof sd != "undefined" &&
	            typeof mean != "undefined")
	            r = sd * r + mean;
	        return r;
	    },
	    debugLines = true,
	    sCollisionSystem = new CollisionSystem(),
	    sInputSystem = new InputSystem(),
	    sBackgroundSystem = new BackgroundSystem(ctx, [20,520,200,550,350,525,400,480,500,480,500,530,600,550,666,550,750,450,900,500,920,300,970,120,850,30,530,70,370,40,370,190,30,190,30,400,60,460,50,500,20,520]);
	sCollisionSystem.addComponent(new DebugDrawBoundsComponent(ctx));
	gameRoot.addObject(new CanvasManager(ctx));
	gameRoot.addObject(sCollisionSystem);
	gameRoot.addObject(sInputSystem);
	gameRoot.addObject(sBackgroundSystem);

	var bullet1 = new GameObject(10,200);
	bullet1.vx = 0.3;
	bullet1.addComponent(new GravityComponent());
	bullet1.addComponent(new GravitateToClickComponent());
	bullet1.addComponent(new MoveComponent());
	bullet1.addComponent(new BounceComponent(5,5,width,height));
	bullet1.addComponent(new BackgroundCollisionComponent());
	bullet1.addComponent(new DebugDrawPathComponent(ctx));
	bullet1.addComponent(new DebugDrawDataComponent(ctx, "H-noAir"));
	bullet1.addComponent(new DrawComponent(ctx, 4, "#333"));
	gameRoot.addObject(bullet1);
	var bullet2 = new GameObject(10,200);
	bullet2.vx = 0.3;
	bullet2.addComponent(new GravityComponent());
	bullet2.addComponent(new AirResistanceComponent(1));
	bullet2.addComponent(new MoveComponent());
	bullet2.addComponent(new BounceComponent(5,5,width,height));
	bullet2.addComponent(new BackgroundCollisionComponent());
	bullet2.addComponent(new DebugDrawPathComponent(ctx));
	bullet2.addComponent(new DebugDrawDataComponent(ctx, "H-Air"));
	bullet2.addComponent(new DrawComponent(ctx, 4, "#333"));
	gameRoot.addObject(bullet2);
	var bullet3 = new GameObject(800,100);
	bullet3.addComponent(new GravityComponent());
	bullet3.addComponent(new MoveComponent());
	bullet3.addComponent(new BounceComponent(5,5,width,height));
	bullet3.addComponent(new BackgroundCollisionComponent());
	bullet3.addComponent(new DebugDrawPathComponent(ctx));
	bullet3.addComponent(new DebugDrawDataComponent(ctx, "V-noAir"));
	bullet3.addComponent(new DrawComponent(ctx, 4, "#333"));
	gameRoot.addObject(bullet3);
	var bullet4 = new GameObject(840,100);
	bullet4.addComponent(new GravityComponent());
	bullet4.addComponent(new AirResistanceComponent(1));
	bullet4.addComponent(new MoveComponent());
	bullet4.addComponent(new BounceComponent(5,5,width,height));
	bullet4.addComponent(new BackgroundCollisionComponent());
	bullet4.addComponent(new DebugDrawPathComponent(ctx));
	bullet4.addComponent(new DebugDrawDataComponent(ctx,"V-Air"));
	bullet4.addComponent(new DrawComponent(ctx, 4, "#333"));
	gameRoot.addObject(bullet4);

	var MassiveObject = GameObject.extend("MassiveObject");
	MassiveObject.prototype._init = function(x,y) {
		GameObject.prototype._init.call(this,x,y);
		this.mass = random(0.5,1);
		this.addComponent(new DrawComponent(ctx, 12, "#ff0"));
		this.addComponent(new MoveComponent());
		this.addComponent(new SolidComponent(24,24,this));
	};

	var RedBall = GameObject.extend("RedBall");
	RedBall.prototype._init = function(x,y) {
		GameObject.prototype._init.call(this,x,y);
		this.vx = 0;
		this.vy = 0;
		this.mass = 0.1;
		//this.addComponent(new RandomMoveComponent());

		this.addComponent(new CollisionComponent(ballSize*2,ballSize*2));
		this.addComponent(new MoveComponent());
		this.addComponent(new SolidComponent(ballSize*2,ballSize*2,this));
		this.addComponent(new DrawComponent(ctx, ballSize, "#f00"));
		this.addComponent(new DebugDrawPathComponent(ctx));
	};

	var firstSunIndex = gameRoot.objects.length;
	var suns = [];
	var redBalls = [];
	//for(var i = 0; i < 1; i++){
	//	addSun(width/2,height/2);
	//}
	//for(var i = 0; i < 10; i++){
	//	addRedBall();
	//}
	var pointMass = null;

	function addSun(x,y){
		if(typeof x != "number") x = random(width, width/2);
		if(typeof y != "number") y = random(height, height/2);
		var massiveObject = new MassiveObject(x,y);
		//massiveObject.addComponent(new BounceComponent(12,12,width, height));
		gameRoot.addObjectAt(firstSunIndex,massiveObject);
		for(var i = 0; i < redBalls.length; i++)
			redBalls[i].addComponent(new PointGravityComponent(massiveObject));
		for(var i = 0; i < suns.length; i++){
			massiveObject.addComponent(new PointGravityComponent(suns[i]));
			suns[i].addComponent(new PointGravityComponent(massiveObject));
		}
		if(pointMass){
			massiveObject.addComponent(new PointGravityComponent(pointMass));
		}
		massiveObject.addComponent(new DebugDrawPathComponent(ctx));
		suns.push(massiveObject);
	}
	function addRedBall(x,y){
		if(typeof x != "number") x = random(width, width/2);
		if(typeof y != "number") y = random(height, height/2);
		var redBall = new RedBall(x,y);
		redBall.vx = (Math.random()-0.5)*0.5;
		redBall.vy = (Math.random()-0.5)*0.5;
		if(Math.random() < 0.5){
			for(var j = 0; j < suns.length; j++){
				redBall.addComponent(new PointGravityComponent(suns[j]));
			}
		}else{
			redBall.addComponent(new GravityComponent());
			redBall.addComponent(new BounceComponent(ballSize,ballSize,width,height));
		}
		gameRoot.addObject(redBall);
		redBalls.push(redBall);
	}
	function addMoon(obj){
		var moon = new GameObject(obj.x+10,obj.y+10);
		moon.vx = 0;
		moon.vy = 0;
		moon.mass = 1;
		moon.addComponent(new PointGravityComponent(obj));
		for(var j = 0; j < suns.length; j++){
			//moon.addComponent(new PointGravityComponent(suns[j]));
		}
		moon.addComponent(new MoveComponent());
		moon.addComponent(new CollisionComponent());
		moon.addComponent(new DrawComponent(ctx, 2, "#000"));
		moon.addComponent(new DebugDrawPathComponent(ctx));
		gameRoot.addObject(moon);
		return moon;
	}

	// --------------------
	// Main Game Control
	// --------------------
	var lastTime = 0;
	function loop(t){
		var delta = Math.min(t - lastTime, 1000);
		gameRoot.update(delta);
		lastTime = t;
		requestAnimationFrame(loop);
	}
	requestAnimationFrame(loop);

	// -----
	// UI
	// -----
	document.getElementsByTagName('button')[0].onclick = function(){
		ctx.canvas.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
	};
	document.getElementsByTagName('button')[1].onclick = function(){
		addSun();
	};
	document.getElementsByTagName('button')[2].onclick = function(){
		for(var i = 0; i < 10; i++)
			addRedBall();
	};
	function enableDebugLines(){
		debugLines = true;
		this.innerText = "Disable Debug Lines";
		this.onclick = disableDebugLines;
	}
	function disableDebugLines(){
		debugLines = false;
		this.innerText = "Enable Debug Lines";
		this.onclick = enableDebugLines;
	}
	document.getElementsByTagName('button')[3].onclick = debugLines ? disableDebugLines : enableDebugLines;
	document.getElementsByTagName('button')[3].innerText = debugLines ? "Disable Debug Lines" : "Enable Debug Lines";
	document.getElementsByTagName('canvas')[0].onclick = function(event){
		if(pointMass == null){
			pointMass = new GameObject(event.x,event.y);
			pointMass.name = "PointMass";
			pointMass.mass = 1;
			for(var i = 0; i < redBalls.length; i++)
				redBalls[i].addComponent(new PointGravityComponent(pointMass));
			for(var j = 0; j < suns.length; j++){
				suns[j].addComponent(new PointGravityComponent(pointMass));
			}
			pointMass.addComponent(new MoveToClickComponent());
			pointMass.addComponent(new DrawComponent(ctx, 2, "#000"));
			gameRoot.addObject(pointMass);
		}
		sInputSystem.click(event.offsetX, event.offsetY);
	}
	var div = document.getElementsByTagName('div')[0];
	document.getElementsByTagName('button')[4].onclick = function(){
		var f = function(){div.innerHTML = gameRoot.toHTML();};
		setInterval(f,100);
		f();
	}
}
</script>
</html>